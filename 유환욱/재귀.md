# 재귀

하나의 함수에서 자기 자신을 다시 호출해 작업을 수행하는 알고리즘

    ```c++
    void function(int n){
      if(n==0) return;
      cout << n << ' ';
      function(n-1);
    }
    ```

## 문제 해결 전략

<hr>

- 여태까지의 알고리즘 문제들은 절차지향적인 사고를 통해 문제 해결
- 하지만 재귀를 풀기 위해서는 귀납적인 방식의 이해 필요

## 절차지향적 사고란?

<hr>

- 위의 주어진 코드를 예시로 사고의 흐름을 파악해보자.
- 3출력 -> function(2) 호출 -> 2출력 -> function(1) 호출 -> 1출력 -> function(0) 호출

## 귀납적 사고란?

<hr>

- 위의 주어진 코드를 예시로 사고의 흐름을 파악해보자.
- function(1)이 1을 출력한다.
- function(k)가 k k-1 k-2 ... 1을 출력하면
- function(k+1)은 k+1 k k-1 ... 1을 출력한다.
- [k+1 출력] -> [function(k) 호출 = k k-1 k-2 ... 1 출력]

## 재귀함수의 조건

<hr>

- Base condition이라는 특정 입력에 함수를 종료하는 조건이 필요하다.
- 모든 입력은 Base condition으로 수렴해야 한다.

## 재귀에 대한 정보

<hr>

- 함수의 인자로 어떤 것을 받고 어디까지 계산한 후 넘겨줄지 명확하게 정해야 한다.
- 모든 재귀 함수는 반복문만으로 동일한 동작을 하는 함수를 만들 수 있다.
- 재귀는 반복문보다 코드가 간결하지만 메모리/시간에서는 손해를 본다.
- 한 함수가 자기자신을 여러번 호출하게 되면 비효율적일 수 있다.

```c++
int fibo(int n){
  if(n <= 1) return 1;
  return fibo(n-1) + fibo(n-2);
}
```

- 재귀함수가 자기자신을 부를때 스택 영역에 계속 누적이 됨. [메모리 구조](http://www.tcpschool.com/c/c_memory_structure)

## 재귀 푸는 법

<hr>

1. 함수의 정의를 생각하자
2. base condition을 정의하자
3. 재귀 식을 풀어 쓰고 그에 해당하는 코드를 작성하자
