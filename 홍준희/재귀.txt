재귀

수학적 귀납법의 향연
절차적으로 1~2~3으로 하는것이 아니라
1되고
k될때 k+1로 생각하자

이렇게 재귀 함수를 만들어낼 수 있고 꼭 절차지향적인 사고 대신 귀납적인 사고로 이 코드가 
올바른 답을 낸다는 사실을 이해하면 좋겠습니다. 물론 이 문제까지는 예를 들어 POW(5, 14, 3)이 
POW(5, 7, 3)을 부르고, POW(5, 7, 3)이 POW(5, 3, 3)을 부르고 이런식으로 절차지향적인 사고로 
따라가는게 어렵지 않지만 점점 그렇게 따라들어가려고 하면 머릿속이 너무 복잡해질
 문제들을 만나게 될 것입니다. 그 때 재귀 함수를 잘 짜려면 귀납적인 사고, 
즉 base condition을 잘 잡아뒀고 k승의 결과를 토대로 2k, 2k+1승의 결과를 계산할 수 있으니 
마치 도미노를 쓰러트리는 것 처럼 모든 결과가 잘 계산될 것이다로 함수를 이해할 필요가 있습니다.

종결 조건 base condition 필요하고
재귀함수는 종결조건으로 수렴해야한다. 그래야 무한루프 안돈다

함수 형태, 정의 , 어떤것 인자로? 어디까지 계산해 넘기기? 결정해야한다

반복문으로도 가능하니 재귀vs 반복문 고민하기

재귀 메모리 시간 낭비 크다.

자기자신 여러번 호출하면 비효율 ex full binary tree


하노이 탑
1일때 되고
k일때 k+1이  2a+1로 되니
다 된다.
총 이동횟수 수열 2^n-1

함수 정의 그냥 1 -> 3으로만 하면
k일때 k-1의움직임 고려 못하니
시작, 도착 인자로 받기

종결 n=1일때  , n=0일때 더 간결

재귀 n-1개 2번기둥
n번째  3번기둥
n-1개 3번기둥으로
