<h1>Dynamic Programming (동적 계획법)</h1>
목적
<br> 모든 경우의 수를 따져야 함. 그 경우의 수가 너무 많아서 속도가 느려지는 문제를 개선하고자 <b>수행 시간을 단축</b>하고자 만들어진 알고리즘입니다.
<br><br>
메모리를 사용해서 중복 연산을 줄이고 중복 연산을 줄여서 수행 속도를 개선함.

메모리를 사용한다 --> 배열 혹은 자료구조를 만든다
<br>중복 연산을 줄인다 --> 연산한 결과를 배열에 담는다

<br>기억하기 알고리즘
<br>연산한 내용을 기억해 놓고 다음에도 그 연산이 필요할 때 기억해 놓은 값을 사용해서 문제를 푸는 알고리즘


<br><br>
다이나믹 프로그래밍의 조건
1. 큰 문제를 작은 문제로 나눌 수 있다 --> 최적 부분 구조
2. 동일한 작은 문제를 반복적으로 해결해야 할 때 --> 중복되는 부분 문제


<br><br>
다이나믹 프로그래밍의 구현은 두 가지 방식으로 구성
1. Top Down(하향식)
<br>메모이제이션(Memoization)
<br>한 번 계산한 결과를 메모리 공간에 메모하는 기법.
같은 문제를 다시 호출하면 메모했던 결과를 가져온다.
<br>값을 기록해 놓는다는 점에서 캐싱이라고도 한다.
2. Bottom up(상향식)
<br> 작은 문제부터 해결하여 큰 문제를 해결하는 방식

<br><br>11053번

<pre><code>
n = int(input())
a = list(map(int, input().split()))
dp = [0 for i in range(n)]
for i in range(n):
    for j in range(i):
        if a[i] > a[j] and dp[i] < dp[j]:
            dp[i] = dp[j]
    dp[i] += 1
print(max(dp))
</code>
