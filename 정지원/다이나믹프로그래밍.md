# 다이나믹프로그래밍

강의:바킹독님 0x10 다이나믹 프로그래밍 강의
이번 강의에서는 문제를 주구장창 푼다.

DP(Dynamic programing)이란? 여러 개 하위 문제 풀고 쌓아올려서 주어진 문제 해결한다.
=>즉, 문제를 찾아내기 위한 점화식을 찾고  점화식의 항을 밑에서부터 차례로 구해나가서 답을 알아내는 형태의 알고리즘을 말합니다.

### 피보나치 수열을 재귀로 했을 때와 DP로 했을 때 비교
##### 재귀의 경우
피보나치 수열의 N번째 항을 지금처럼 재귀적으로 구하면 중복된 연산이 계속 발생해서 O(1.618^(N))의 시간복잡도를 가진다.
![image](https://user-images.githubusercontent.com/101682617/185390847-55ed8ae9-b4fb-4aa2-bd5a-24c82c0e2cb2.png)
(바킹독님의 0x0B 재귀 강의 참고 및
https://chanos.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%88%98%EC%97%B4%EC%9D%98-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-%EC%99%84%EB%B2%BD%ED%9E%88-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0 참고)
##### DP의 경우
미리 배열을 만들어두고 점화식을 구해서 배열 인덱스 0부터 피보나치 수를 채운다.
재귀로 피보나치 수열을 짜던 것처럼 중간 결과를 저장해서 이용하지 않음
그러므로 시간 복잡도 O(n)으로 N번째 피보나치 수열을 구할 수 있다.
```cpp
int fibo(int n) {
int f[20];
f[0] = f[1] = 1;
for (int i=2; i<=n; i++)
  f[i]=f[i-1]+f[i-2];
 return f[n];
}
```
