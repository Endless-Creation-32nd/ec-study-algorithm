# 다이나믹프로그래밍

강의:바킹독님 0x10 다이나믹 프로그래밍 강의
이번 강의에서는 문제를 주구장창 푼다.

DP(Dynamic programing)이란? 여러 개 하위 문제 풀고 쌓아올려서 주어진 문제 해결한다.
=>즉, 문제를 찾아내기 위한 점화식을 찾고  점화식의 항을 밑에서부터 차례로 구해나가서 답을 알아내는 형태의 알고리즘을 말합니다.

### 피보나치 수열을 재귀로 했을 때와 DP로 했을 때 비교
##### 재귀의 경우
피보나치 수열의 N번째 항을 지금처럼 재귀적으로 구하면 중복된 연산이 계속 발생해서 O(1.618^(N))의 시간복잡도를 가진다.
![image](https://user-images.githubusercontent.com/101682617/185390847-55ed8ae9-b4fb-4aa2-bd5a-24c82c0e2cb2.png)
(바킹독님의 0x0B 재귀 강의 참고 및
https://chanos.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%88%98%EC%97%B4%EC%9D%98-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-%EC%99%84%EB%B2%BD%ED%9E%88-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0 참고)
##### DP의 경우
미리 배열을 만들어두고 점화식을 구해서 배열 인덱스 0부터 피보나치 수를 채운다.
재귀로 피보나치 수열을 짜던 것처럼 중간 결과를 저장해서 이용하지 않음
그러므로 시간 복잡도 O(n)으로 N번째 피보나치 수열을 구할 수 있다.
```cpp
int fibo(int n) {
int f[20];
f[0] = f[1] = 1;
for (int i=2; i<=n; i++)
  f[i]=f[i-1]+f[i-2];
 return f[n];
}
```

### DP 푸는 방법
1. 테이블 정의하기
2. 점화식 찾기
3. 초기값 정하기

점화식을 잘 끌어내자. 테이블을 찾고 점화식을 끌어내는데 연습

#### BOJ 1463 1로 만들기
문제 링크 https://www.acmicpc.net/problem/1463
처음 내 생각)재귀로 풀면 될 것 같다. 그런데 재귀로 풀면 너무 힘들 것 같다.

사용할 수 있는 연산을 정의해보자.
1번 연산) if(X%3==0) X/3;
2번 연산) if(X%2==0) X/2;
3번 연산) else X-=1;

힌트) 10은 10->9->3->1 총 세번의 절차를 거쳐서 1로 만들 수 있다.

힌트를 본 내 생각)3의 배수도, 2의 배수도 아니면 3번 연산(1을 빼기)를 이용해서 X가 3의 배수나 2의 배수가 되도록 만드는 것 같다.

재귀를 이용해보면) 1은 0번에
2는 2로 한 번 나눠서
10은 10-1하고 9,3,1 이렇게 3으로 두 번 나누면 1이 되서 3번
3은 3으로 한 번 나눠서
4는 2로 두번 나누거나 or 1을 빼고 3으로 나누기 //어찌되었든 2번
5는 -1 하면 4가 되는데 4의 경우 2번이니 2회+1회=3회 걸림
6은 3의 배수이자 2의 배수니 2회
7은 -1을 한번하고 6과 같은 절차니 2+1=3회 걸림

n이 2의 배수나 3의 배수여서 x번 연산을 해서 1을 만들면 n+1은 x+1번 걸린다. n+1은 2의 배수나 3의 배수 둘 다 아니어야 한다.
그런데 이에 관한 반례는 없는가?
이런 식으로 재귀적으로 구할 수도 있는데...
피보나치 수열 재귀식 썼을 때처럼 중간 과정을 쓰게 되면 시간복잡도가 증가하게 된다.
그래서 DP의 방식을 취해서 점화식으로 나타낸다면?




###### 번외) 깃허브 코드 수정방법
수정방법은 gotofile을 누르고 수정하면 된다.
